# 总览

`Lua` 是一种**嵌入式语言**（ `embedded language` ），这就意味着 `Lua` 并**不是一个独立运行的应用**，而是一个**库**，它可以链接到其他应用程序，将 `Lua` 的功能融入这些应用。

> [!tip|label: 思考]
> **问**：如果 `Lua` 不是一个独立的应用，那么为什么系统安装了 `Lua` 之后就可以一直独立的使用它呢？
>  
> **答**：这是因为 `Lua` **解释器**，即**可执行的Lua**。这个可执行文件是一个小应用，大概有 `600` 行代码，它是用 `Lua` 标准库实现的**独立解释器**（ `stand-alone interpreter` ）。这个解释器负责与用户交互，将用户的文件和字符串传递给 `Lua` **标准库**，由标准库完成主要的工作（例如：真正地运行 `Lua` 代码）。

由于能被当做库来扩展某个应用程序，所以 `Lua` 是一种嵌入式语言。同时，使用了 `Lua` 语言的程序也可以在 `Lua` 环境中注册新的函数，比如用 `C` 语言（或其他语言）实现的函数，从而增加一些无法直接用 `Lua` 语言编写的功能，因此 `Lua` 也是一种**可扩展的语言**（ `extensible language` ）。

上述两种对 `Lua` 语言的定位（嵌入式语言和可扩展语言）分别对应 `C` 语言和 `Lua` 语言之间的两种交互形式。在第一种形式中， `C` 语言拥有绝对的控制权，而 `Lua` 语言被用作库，这种交互形式中的 `C` 代码被称为**应用代码**（ `application code` ）。在第二种形式中， `Lua` 语言拥有控制权，而 `C` 语言被用作库，此时的 `C` 代码被称为**库代码**（ `library code` ）。应用代码和库代码都使用相同的 `API` 与 `Lua` 语言通信，这些 `API` 被称为 `C API` 。

`C API` 是一个**函数**、**常量**和**类型**组成的集合，有了它， `C` 语言代码就能与 `Lua` 语言交互。 `C API` 包括读写 `Lua` 全局变量的函数、调用 `Lua` 函数的函数、运行 `Lua` 代码段的函数以及注册 `C` 函数（以便于其后可被 `Lua` 代码调用）的函数等。通过调用 `C API` 、 `C` 代码几乎可以做 `Lua` 代码能够做的所有事情。

`C API` 遵循 `C` 语言的**操作模式**（ `modus operandi` ），与 `Lua` 的操作模式有很大区别，在使用 `C` 语言编程时，我们必须注意**类型检查**、**错误恢复**、**内存分配错误**和其他一些复杂的概念。 `C API` 中的大多数函数都不会检查其参数的正确性，我们必须在调用函数前确保参数的合法性。一旦出错，程序会直接崩溃而不会收到规范的错误信息。此外， `C API` 强调的是灵活性和简洁性，某些情况下会以牺牲易用性为代价，即便是常见的需求，也可能需要调用几个 `API` 。这么做虽然有些繁琐，但我们却可以完全控制所有细节。

**不要试图理解所有的细节**，但是记住，在 `Lua` 语言参考手册中总是能够找到关于某个特定函数的更多细节。此外，在 `Lua` 的发行版中也可以找到若干使用 `C API` 的实例。 `Lua` 独立解释器（ `lua.c` ）给出了几个应用代码的实例，而 `Lua` 标准库（ `lmathlib.c` 、 `lstrlib.c` 等）则给出了几个库代码的实例。
