# 使用C API进行错误处理

`Lua` 中所有的结构都是**动态**的：他们会按需扩展，并且在可能时最后重新**收缩**（ `shrink` ）。这意味着在 `Lua` 中**内存分配失败可能无处不在**，几乎所有的操作最终都可能会面临内存分配失败。此外，许多操作可能会抛出异常。例如，访问一个全局变量可能会触发 `__index` 元方法，而该元方法又可能会抛出异常。最后，分配内存的操作会触发垃圾收集器，而垃圾收集器又可能会调用同样可能抛出异常的析构器。简而言之， `Lua API` 中的绝大部分函数都可能抛出异常。

`Lua` 语言使用**异常**来提示错误，而没有在 `API` 的每个操作中使用错误码。与 `C++` 或 `Java` 不同， `C` 语言没有提供异常处理机制。为了解决这个问题， `Lua` 使用了 `C` 语言中的 `setjmp` 机制， `setjmp` 营造了一个类似异常处理的机制。因此，大多数 `API` 函数都可以抛出异常（即调用函数 `longjmp` ）而不是直接返回。

在编写库代码时（被 `Lua` 语言调用的 `C` 函数），由于 `Lua` 会捕获所有异常，因此，对我们来说使用 `longjmp` 并不用进行额外的操作。不过，在编写应用程序代码（调用 `Lua` 的 `C` 代码）时，则必须提供一种捕获异常的方式。
